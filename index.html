<!DOCTYPE html>
<!-- saved from url=(0039)http://q.dmzj.com/1804/6605/47365.shtml -->
<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

	<title>第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说</title>
	<meta name="Keywords" content="幼女战记,第一卷 Deus lo vult,第参章 守望莱茵,幼女战记小说,幼女战记手机轻小说,幼女战记在线轻小说">
	<meta name="Description" content="动漫之家在线轻小说站手机版提供幼女战记小说第一卷 Deus lo vult第参章 守望莱茵在线阅读和手机轻小说下载，是用手机观看幼女战记轻小说最舒适的网站。">
	<meta name="viewport" content="width=device-width,user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="stylesheet" href="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/style.css">
    <script type="text/javascript" async="" charset="utf-8" src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/core.php"></script><script type="text/javascript" src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/jquery-1.8.2.min.js.download"></script>
    <script type="text/javascript" src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/jquery.cookie.js.download"></script>
	<script>
	var g_lnovel_id = res_id = '1804';
	var g_chapter_id = chapter_id = '47365';
    var g_volume_id = '6605';
	var g_lnovel_url = '/1804/index.shtml';
	var g_lnovel_name = '幼女战记';
	var g_chapter_url ='/1804/6605/47365.shtml';
	var g_chapter_name ='第参章 守望莱茵';
	var g_lnovel_code = '7324db62dd960bb8e4ee4a68a99e799c';
	var res_type= 3;
	var g_chapter_pages_url = ["","/1804/6605/47365_2.shtml","/1804/6605/47365_3.shtml","/1804/6605/47365_4.shtml","/1804/6605/47365_5.shtml","/1804/6605/47365_6.shtml","/1804/6605/47365_7.shtml","/1804/6605/47365_8.shtml","/1804/6605/47365_9.shtml","/1804/6605/47365_10.shtml","/1804/6605/47365_11.shtml","/1804/6605/47365_12.shtml","/1804/6605/47365_13.shtml","/1804/6605/47365_14.shtml","/1804/6605/47365_15.shtml","/1804/6605/47365_16.shtml","/1804/6605/47365_17.shtml","/1804/6605/47365_18.shtml","/1804/6605/47365_19.shtml","/1804/6605/47365_20.shtml","/1804/6605/47365_21.shtml","/1804/6605/47365_22.shtml","/1804/6605/47365_23.shtml","/1804/6605/47365_24.shtml","/1804/6605/47365_25.shtml","/1804/6605/47365_26.shtml"];
	var g_chapter_pages_count = 26;
	var g_chapter_page = 1;
	var g_chapter_font_size = 14;
	</script>
	<script type="text/javascript" src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/lnovel_mobile.js.download"></script>
</head>
<body style="background-color:#FCFCFC;">
	<div class="txt">
		<div id="toolbar" class="top" style="" display="1">
			<h2 class="tit">幼女战记</h2>
			<a href="http://q.dmzj.com/1804/index.shtml" title="" class="cn1"></a>
			<a href="http://q.dmzj.com/1804/6605/47365.shtml" title="" class="cn3" style="display:none;"><span class="num">999</span></a>
			<a href="javascript:;" onclick="toShare()" title="分享" class="cn4"></a>
		</div>
		<div class="con" id="page_contents">
			<h1 class="tit">第一卷 Deus lo vult 第参章 守望莱茵</h1>
			<div style="color:#999;text-align:center;">第<span id="page_num_title">1</span>页/共26页</div>
			<div class="t" id="chapter_contents_first">
				<p>统一历一九一四年七月十八日　帝部柏卢／某处</p><p>
</p>
<strong>一、白盒测试</strong></span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">&nbsp;&nbsp;&nbsp; 根据软件产品的内部工作过程，在计算机上进行测试，以证实每种内部操作是否符合设计规格要求，所有内部成分是否已经过检查。这种测试方法就是白盒测试。白盒测试把测试对象看做一个打开的盒子，允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　不论是黑盒测试，还是白盒测试，都不可能把所有可能的输入数据都拿来进行所谓的穷举测试。因为可能的测试输入数据数目往往达到天文数字。下面让我们看两个例子。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　假设一个程序</span><span style="font-family: 'Times New Roman','serif'">P</span><span style="font-family: 宋体">有输入</span><span style="font-family: 'Times New Roman','serif'">X</span><span style="font-family: 宋体">和</span><span style="font-family: 'Times New Roman','serif'">Y</span><span style="font-family: 宋体">及输出</span><span style="font-family: 'Times New Roman','serif'">Z</span><span style="font-family: 宋体">，参看图</span><span style="font-family: 'Times New Roman','serif'">10-4-1</span><span style="font-family: 宋体">。在字长为</span><span style="font-family: 'Times New Roman','serif'">32</span><span style="font-family: 宋体">位的计算机上运行。如果</span><span style="font-family: 'Times New Roman','serif'">X </span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">Y</span><span style="font-family: 宋体">只取整数，考虑把所有的</span><span style="font-family: 'Times New Roman','serif'">X </span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">Y</span><span style="font-family: 宋体">值都做为测试数据，按黑盒测试方法进行穷举测试，力图全面、无遗漏地</span><span style="font-family: 'Times New Roman','serif'">&#8220;</span><span style="font-family: 宋体">挖掘</span><span style="font-family: 'Times New Roman','serif'">&#8221;</span><span style="font-family: 宋体">出程序中的所有错误。这样做可能采用的测试数据组（</span><span style="font-family: 'Times New Roman','serif'">Xi</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">Yi</span><span style="font-family: 宋体">）的最大可能数目为：</span> <span style="font-family: 宋体">。如果程序</span>P<span style="font-family: 宋体">测试一组</span><span style="font-family: 'Times New Roman','serif'">X</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">Y</span><span style="font-family: 宋体">数据需要</span><span style="font-family: 'Times New Roman','serif'"> 1</span><span style="font-family: 宋体">毫秒，且一天工作</span><span style="font-family: 'Times New Roman','serif'">24</span><span style="font-family: 宋体">小时，一年工作</span><span style="font-family: 'Times New Roman','serif'">365</span><span style="font-family: 宋体">天，要完成</span><span style="font-family: 'Times New Roman','serif'">264</span><span style="font-family: 宋体">组测试，需要</span><span style="font-family: 'Times New Roman','serif'">5</span><span style="font-family: 宋体">亿年。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="78" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b1.JPG" width="158" border="0" /><br />图</span> 10-4-1<span style="font-family: 宋体">　黑盒子</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　而对一个具有多重选择和循环嵌套的程序，不同的路径数目也可能是天文数字。设给出一个如图</span> 10-4-2<span style="font-family: 宋体">所示的小程序的流程图，其中包括了一个执行达</span><span style="font-family: 'Times New Roman','serif'">20</span><span style="font-family: 宋体">次的循环。那么它所包含的不同执行路径数高达</span> <span style="font-family: 宋体">条，若要对它进行穷举测试，覆盖所有的路径。假使测试程序对每一条路径进行测试需要</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">毫秒，同样假定一天工作</span><span style="font-family: 'Times New Roman','serif'">24</span><span style="font-family: 宋体">小时，一年工作</span><span style="font-family: 'Times New Roman','serif'">365 </span><span style="font-family: 宋体">天，那么要想把如图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-2</span><span style="font-family: 宋体">所示的小程序的所有路径测试完，则需要</span><span style="font-family: 'Times New Roman','serif'">3170</span><span style="font-family: 宋体">年。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img style="width: 372px; height: 187px" height="187" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b2.JPG" width="372" border="0" /><br />图</span> 10-4-2<span style="font-family: 宋体">　白盒测试中的穷举测试</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　以上的分析表明，实行穷举测试，由于工作量过大，实施起来是不现实的。任何软件开发项目都要受到期限、费用、人力和机时等条件的限制，尽管为了充分揭露程序中所有隐藏错误，需要针对所有可能的数据进行测试，但事实告诉我们，这样做是不可能的。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　软件工程的总目标是充分利用有限的人力、物力资源，高效率、高质量、低成本地完成软件开发项目。在测试阶段既然穷举测试不可行，为了节省时间和资源，提高测试效率，就必须要从数量极大的可用测试用例中精心地挑选少量的测试数据，使得采用这些测试数据能够达到最佳的测试效果，能够高效率地把隐藏的错误揭露出来。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体"><strong>二、逻辑覆盖</strong></span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。属白盒测试。这一方法要求测试人员对程序的逻辑结构有清楚的了解，甚至要能掌握源程序的所有细节。由于覆盖测试的目标不同，逻辑覆盖又可分为：语句覆盖、判定覆盖、判定－条件覆盖、条件组合覆盖及路径覆盖。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">1.</span><span style="font-family: 宋体">语句覆盖</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　语句覆盖就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。这种覆盖又称为点覆盖，它使得程序中每个可执行语句都得到执行，但它是最弱的逻辑覆盖准，效果有限，必须与其他方法交互使用。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">2.</span><span style="font-family: 宋体">判定覆盖</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。判定覆盖又称为分支覆盖。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　判定覆盖只比语句覆盖稍强一些，但实际效果表明，只是判定覆盖，还不能保证一定能查出在判断的条件中存在的错误。因此，还需要更强的逻辑覆盖准则去检验判断内部条件。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">3.</span><span style="font-family: 宋体">条件覆盖</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　条件覆盖深入到判定中的每个条件，但可能不能满足判定覆盖的要求。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">4.</span><span style="font-family: 宋体">判定－条件覆盖</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　判定－条件覆盖就是设计足够的测试用例，使得判断中每个条件的所有可能取值至少执行一次，同时每个判断本身的所有可能判断结果至少执行一次。换言之，即是要求各个判断的所有可能的条件取值组合至少执行一次。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　判定－条件覆盖有缺陷。从表面上来看，它测试了所有条件的取值。但是事实并非如此。往往某些条件掩盖了另一些条件。会遗漏某些条件取值错误的情况。为彻底地检查所有条件的取值，需要将判定语句中给出的复合条件表达式进行分解，形成由多个基本判定嵌套的流程图。这样就可以有效地检查所有的条件是否正确了。</span><br /></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="204" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b3.JPG" width="243" border="0" /><br />图</span> 10-4-3<span style="font-family: 宋体">（</span>a<span style="font-family: 宋体">）　复合判定的例子</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="204" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b4.JPG" width="269" border="0" /><br />图</span> 10-4-3<span style="font-family: 宋体">（</span>b<span style="font-family: 宋体">）　改为单个条件判定的嵌套结构的例子</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">5.</span><span style="font-family: 宋体">多重条件覆盖</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　多重条件覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　这是一种相当强的覆盖准则，可以有效地检查各种可能的条件取值的组合是否正确。它不但可覆盖所有条件的可能取值的组合，还可覆盖所有判断的可取分支，但可能有的路径会遗漏掉。测试还不完全。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">6.</span><span style="font-family: 宋体">路径测试</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　路径测试就是设计足够的测试用例，覆盖程序中所有可能的路径。这是最强的覆盖准则。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。下面我们做一分析。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体"><strong>三、关于控制结构测试的一些讨论</strong></span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">1.</span><span style="font-family: 宋体">分支结构的路径数</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　当程序中判定多于一个时，形成的分支结构可以分为两类：嵌套型分支结构和连锁型分支结构。如图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-4</span><span style="font-family: 宋体">所示。对于嵌套型分支结构，若有</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">个判定语句，则需要</span><span style="font-family: 'Times New Roman','serif'">n+1</span><span style="font-family: 宋体">个测试用例；但对连锁型分支结构，若有</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">个判定语句，则需要有</span> <span style="font-family: 宋体">个测试用例，去覆盖它的</span> <span style="font-family: 宋体">条路径。当</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">较大时将无法测试。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="196" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b5.JPG" width="163" border="0" /><br />（</span>a<span style="font-family: 宋体">）嵌套型分支结构</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="224" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b6.JPG" width="102" border="0" /><br />（</span>b<span style="font-family: 宋体">）连锁型分支结构</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体">图</span> 10-4-4<span style="font-family: 宋体">　分支的两种类型</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　为减少测试用例的数目，可采用试验设计法，抽取部分路径进行测试。由于抽样服从均匀分布，因此，在假定各条路径的重要性相同，或暂不明确各条路径的重要性的情况下可以做到均匀抽样。如果明确了各条路径的重要性，还可以采取加权的办法，筛选掉部分路径，再用如下的措施进行抽样。具体步骤如下：</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">设耦合型分支结构中有</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">个判定，计算满足关系式</span> <span style="font-family: 宋体">的最小自然数</span><span style="font-family: 'Times New Roman','serif'">m</span><span style="font-family: 宋体">；</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">2</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">设</span> <span style="font-family: 宋体">，取正交表</span><span style="font-family: 'Times New Roman','serif'">L4</span><span style="font-family: 宋体">，并利用它设计测试数据。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　例如，一个耦合型分支结构中有三个判定语句</span><span style="font-family: 'Times New Roman','serif'">P1</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">P2</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">P3</span><span style="font-family: 宋体">。它全部路径是</span><span style="font-family: 'Times New Roman','serif'">23</span><span style="font-family: 宋体">＝</span><span style="font-family: 'Times New Roman','serif'">8</span><span style="font-family: 宋体">条。先计算</span> <span style="font-family: 宋体">的</span><span style="font-family: 'Times New Roman','serif'">t</span><span style="font-family: 宋体">，得</span><span style="font-family: 'Times New Roman','serif'">t= 4</span><span style="font-family: 宋体">。取正交表</span><span style="font-family: 'Times New Roman','serif'">L4</span><span style="font-family: 宋体">，如图</span><span style="font-family: 'Times New Roman','serif'">10-</span>4-5<span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">a</span><span style="font-family: 宋体">）所示，把每一列当做一个判定，每一行当做可取的测试用例，则正交表</span><span style="font-family: 'Times New Roman','serif'">L4</span><span style="font-family: 宋体">最多可取三个判定，分别代之以</span><span style="font-family: 'Times New Roman','serif'">P1</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">P2</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">P3</span><span style="font-family: 宋体">。判定</span><span style="font-family: 'Times New Roman','serif'">P1</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">P2</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">P3</span><span style="font-family: 宋体">的取假分支和取真分支分别记作</span><span style="font-family: 'Times New Roman','serif'">S1</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">S2</span><span style="font-family: 宋体">；</span><span style="font-family: 'Times New Roman','serif'">S3</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">S4</span><span style="font-family: 宋体">；</span><span style="font-family: 'Times New Roman','serif'">S5</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">S6</span><span style="font-family: 宋体">，用各个判定的取假分支取代正交表</span><span style="font-family: 'Times New Roman','serif'">L4</span><span style="font-family: 宋体">中的</span><span style="font-family: 'Times New Roman','serif'">&#8220;0&#8221;</span><span style="font-family: 宋体">，用取真分支取代正交表中的</span><span style="font-family: 'Times New Roman','serif'">&#8220;1&#8221;</span><span style="font-family: 宋体">，就建立起一个测试路径矩阵，如图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-5</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">b</span><span style="font-family: 宋体">）所示。这样，测试路径数目从</span> <span style="font-family: 宋体">条减少到</span><span style="font-family: 'Times New Roman','serif'">3</span><span style="font-family: 宋体">＋</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">＝</span><span style="font-family: 'Times New Roman','serif'">4</span><span style="font-family: 宋体">条。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="152" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b7.JPG" width="203" border="0" /><br />图</span> 10-4-5<span style="font-family: 宋体">（</span>a<span style="font-family: 宋体">）　正交表</span>L4</p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="162" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b8.JPG" width="400" border="0" /><br />图</span> 10-4-5<span style="font-family: 宋体">（</span>b<span style="font-family: 宋体">）　路径抽样矩阵</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">2.</span><span style="font-family: 宋体">条件测试的策略</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　程序中的条件分为简单条件和复合条件。简单条件是一个布尔变量或一个关系表达式（可加前缀</span><span style="font-family: 'Times New Roman','serif'">NOT</span><span style="font-family: 宋体">），复合条件由简单条件通过逻辑运算符（</span><span style="font-family: 'Times New Roman','serif'">AND</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">OR</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">NOT</span><span style="font-family: 宋体">）和括号连接而成。如果条件出错，至少是条件中某一成分有错。条件中可能的出错类型有：布尔运算符错、布尔变量错、布尔括号错、关系运算符错、算术表达式错。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　如果在一个判定的复合条件表达式中每个布尔变量和关系运算符最多只出现一次，而且没有公共变量，应用一种称之为</span><span style="font-family: 'Times New Roman','serif'">BRO</span><span style="font-family: 宋体">（分支与关系运算符）的测试法可以发现多个布尔运算符或关系运算符错，以及其他错误。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">BRO</span><span style="font-family: 宋体">策略引入条件约束的概念。设有</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">个简单条件的复合条件</span><span style="font-family: 'Times New Roman','serif'">C</span><span style="font-family: 宋体">，其条件约束为</span> <span style="font-family: 宋体">，其中</span> <span style="font-family: 宋体">是条件</span><span style="font-family: 'Times New Roman','serif'">C</span><span style="font-family: 宋体">中第</span><span style="font-family: 'Times New Roman','serif'">i</span><span style="font-family: 宋体">个简单条件的输出约束。如果在</span><span style="font-family: 'Times New Roman','serif'">C</span><span style="font-family: 宋体">的执行过程中，其每个简单条件的输出都满足</span><span style="font-family: 'Times New Roman','serif'">D</span><span style="font-family: 宋体">中对应的约束，则称条件</span><span style="font-family: 'Times New Roman','serif'">C</span><span style="font-family: 宋体">的条件约束</span><span style="font-family: 'Times New Roman','serif'">D</span><span style="font-family: 宋体">由</span><span style="font-family: 'Times New Roman','serif'">C</span><span style="font-family: 宋体">的执行所覆盖。特别地，布尔变量或布尔表达式的输出约束必须是真（</span><span style="font-family: 'Times New Roman','serif'">t</span><span style="font-family: 宋体">）或假（</span><span style="font-family: 'Times New Roman','serif'">f</span><span style="font-family: 宋体">）；关系表达式的输出约束为符号</span><span style="font-family: 'Times New Roman','serif'">&gt;</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">=</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">&lt;</span><span style="font-family: 宋体">。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">设条件为</span> <span style="font-family: 宋体">。其中</span> <span style="font-family: 宋体">是布尔变量，</span> <span style="font-family: 宋体">的输出约束为</span> <span style="font-family: 宋体">，在此，</span> <span style="font-family: 宋体">和</span> <span style="font-family: 宋体">或为</span><span style="font-family: 'Times New Roman','serif'">t</span><span style="font-family: 宋体">或为</span><span style="font-family: 'Times New Roman','serif'">f</span><span style="font-family: 宋体">。则</span> <span style="font-family: 宋体">是</span> <span style="font-family: 宋体">可能的一个约束。覆盖此约束的测试（一次运行）将令</span> <span style="font-family: 宋体">为</span><span style="font-family: 'Times New Roman','serif'">t</span><span style="font-family: 宋体">，</span> <span style="font-family: 宋体">为</span><span style="font-family: 'Times New Roman','serif'">f</span><span style="font-family: 宋体">。</span><span style="font-family: 'Times New Roman','serif'">BR</span>O<span style="font-family: 宋体">策略要求对</span> <span style="font-family: 宋体">的可能约束集合</span> <span style="font-family: 宋体">中的每一个，分别设计一组测试用例。如果布尔运算符有错，这三组测试用例的运行结果必有一组导致</span> <span style="font-family: 宋体">失败。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">2</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">设条件为</span> <span style="font-family: 宋体">。其中</span> <span style="font-family: 宋体">是布尔表达式，</span> <span style="font-family: 宋体">和</span> <span style="font-family: 宋体">是算术表达式，</span> <span style="font-family: 宋体">的输出约束为</span> <span style="font-family: 宋体">，在此，</span> <span style="font-family: 宋体">或为</span><span style="font-family: 'Times New Roman','serif'">t</span><span style="font-family: 宋体">或为</span><span style="font-family: 'Times New Roman','serif'">f</span><span style="font-family: 宋体">；</span> <span style="font-family: 宋体">则是</span><span style="font-family: 'Times New Roman','serif'">&lt;</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">= </span><span style="font-family: 宋体">或</span><span style="font-family: 'Times New Roman','serif'">&gt;</span><span style="font-family: 宋体">。因此，只有</span> <span style="font-family: 宋体">与</span> <span style="font-family: 宋体">中</span> <span style="font-family: 宋体">的不同，可以修改</span> <span style="font-family: 宋体">的约束集合</span> <span style="font-family: 宋体">，导出</span> <span style="font-family: 宋体">的约束集合。因为在</span> <span style="font-family: 宋体">中，</span><span style="font-family: 'Times New Roman','serif'">&#8220;t&#8221;</span><span style="font-family: 宋体">相当于</span><span style="font-family: 'Times New Roman','serif'">&#8220;=&#8221;</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">&#8220;f&#8221;</span><span style="font-family: 宋体">相当于</span><span style="font-family: 'Times New Roman','serif'">&#8220;&lt;&#8221;</span><span style="font-family: 宋体">或</span><span style="font-family: 'Times New Roman','serif'">&#8220;&gt;&#8221;</span><span style="font-family: 宋体">，则</span> <span style="font-family: 宋体">的约束集合为</span> <span style="font-family: 宋体">。据此设计</span><span style="font-family: 'Times New Roman','serif'">4</span><span style="font-family: 宋体">组测试用例，检查</span> <span style="font-family: 宋体">中可能的布尔或关系运算符中的错误。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">3</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">设条件为</span> <span style="font-family: 宋体">。其中</span> <span style="font-family: 宋体">都是算术表达式，</span> <span style="font-family: 宋体">的输出约束为</span> <span style="font-family: 宋体">，在此，</span> <span style="font-family: 宋体">和</span> <span style="font-family: 宋体">的约束均为</span><span style="font-family: 'Times New Roman','serif'">&lt;</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">=</span><span style="font-family: 宋体">、</span><span style="font-family: 'Times New Roman','serif'">&gt;</span><span style="font-family: 宋体">。</span> <span style="font-family: 宋体">中只有</span> <span style="font-family: 宋体">与</span> <span style="font-family: 宋体">中的</span> <span style="font-family: 宋体">不同，可以修改</span> <span style="font-family: 宋体">的约束集合</span> <span style="font-family: 宋体">，导出</span> <span style="font-family: 宋体">的约束集合。因为在</span> <span style="font-family: 宋体">中，</span><span style="font-family: 'Times New Roman','serif'">&#8220;t&#8221;</span> <span style="font-family: 宋体">相当于</span><span style="font-family: 'Times New Roman','serif'">&#8220;&gt;&#8221;</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">"f"</span><span style="font-family: 宋体">相当于</span><span style="font-family: 'Times New Roman','serif'">&#8220;&lt;&#8221;</span><span style="font-family: 宋体">或</span><span style="font-family: 'Times New Roman','serif'">&#8220;=&#8221;</span><span style="font-family: 宋体">，则</span> <span style="font-family: 宋体">的约束集合为</span> <span style="font-family: 宋体">。根据这个约束集合设计测试用例，就能够检测</span> <span style="font-family: 宋体">中的关系运算符中的错误。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">3.</span><span style="font-family: 宋体">循环测试</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　循环分为</span><span style="font-family: 'Times New Roman','serif'">4</span><span style="font-family: 宋体">种不同类型：简单循环、连锁循环、嵌套循环和非结构循环，见图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-6</span><span style="font-family: 宋体">。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="279" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b9.JPG" width="416" border="0" /><br />图</span> 10-4-6<span style="font-family: 宋体">　循环的分类</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　对于简单循环，测试应包括以下几种，其中的</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">表示循环允许的最大次数。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">零次循环：从循环入口直接跳到循环出口。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">2</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">一次循环：查找循环初始值方面的错误。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">3</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">二次循环：检查在多次循环时才能暴露的错误。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">4</span><span style="font-family: 宋体">）</span><span style="font-family: 'Times New Roman','serif'"> m</span><span style="font-family: 宋体">次循环：此时的</span><span style="font-family: 'Times New Roman','serif'">m</span><span style="font-family: 宋体">＜</span><span style="font-family: 'Times New Roman','serif'">n</span><span style="font-family: 宋体">，也是检查在多次循环时才能暴露的错误。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">&#183;</span><span style="font-family: 宋体">最大次数循环、比最大次数多一次的循环、比最大次数少一次的循环。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　对于嵌套循环，不能将简单循环的测试方法简单地扩大到嵌套循环，因为可能的测试数目将随嵌套层次的增加呈几何倍数增长。这可能导致一个天文数字的测试数目。下面给出一种有助于减少测试数目的测试方法。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">&#183;</span><span style="font-family: 宋体">除最内层循环外，从最内层循环开始，置所有其他层的循环为最小值；</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">&#183;</span><span style="font-family: 宋体">对最内层循环做简单循环的全部测试。测试时保持所有外层循环的循环变量为最小值。另外，对越界值和非法值做类似的测试。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">&#183;</span><span style="font-family: 宋体">逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取</span><span style="font-family: 'Times New Roman','serif'">&#8220;</span><span style="font-family: 宋体">典型</span><span style="font-family: 'Times New Roman','serif'">&#8221;</span><span style="font-family: 宋体">值。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">&#183;</span><span style="font-family: 宋体">反复进行，直到所有各层循环测试完毕。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">&#183;</span><span style="font-family: 宋体">对全部各层循环同时取最小循环次数，或者同时取最大循环次数。对于后一种测试，由于测试量太大，需人为指定最大循环次数。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　对于连锁循环，要区别两种情况。如果各个循环互相独立，则连锁循环可以用与简单循环相同的方法进行测试。例如，有两个循环处于连锁状态，则前一个循环的循环变量的值就可以做为后一个循环的初值。但如果几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　对于非结构循环，应该使用结构化程序设计方法重新设计测试用例。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体"><strong>四、基本路径测试</strong></span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　如果把覆盖的路径数压缩到一定限度内，例如，程序中的循环体只执行零次和一次，就成为基本路径测试。它是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　设计出的测试用例要保证在测试中，程序的每一个可执行语句至少要执行一次。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">1.</span><span style="font-family: 宋体">程序的控制流图</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　控制流图是描述程序控制流的一种图示方法。基本控制构造的图形符号如图</span><span style="font-family: 'Times New Roman','serif'">10-4-7</span><span style="font-family: 宋体">所示。符号</span><span style="font-family: 'Times New Roman','serif'">&#9675;</span><span style="font-family: 宋体">称为控制流图的一个结点，一组顺序处理框可以映射为一个单一的结点。控制流图中的箭头称为边，它表示了控制流的方向，在选择或多分支结构中分支的汇聚处，即使没有执行语句也应该有一个汇聚结点。边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="231" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b10.JPG" width="257" border="0" /><br />图</span> 10-4-7<span style="font-family: 宋体">　控制流图的各种图形符号</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　如果判定中的条件表达式是复合条件时，即条件表达式是由一个或多个逻辑运算符（</span><span style="font-family: 'Times New Roman','serif'">OR</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">AND</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">NAND</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">NOR</span><span style="font-family: 宋体">）连接的逻辑表达式，则需要改复合条件的判定为一系列只有单个条件的嵌套的判定。例如对应图</span><span style="font-family: 'Times New Roman','serif'"> 1</span>0-4-8<span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">a</span><span style="font-family: 宋体">）的复合条件的判定，应该画成如图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-8</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">b</span><span style="font-family: 宋体">）所示的控制流图。条件语句</span><span style="font-family: 'Times New Roman','serif'">ifaORb</span><span style="font-family: 宋体">中条件</span><span style="font-family: 'Times New Roman','serif'">a</span><span style="font-family: 宋体">和条件</span><span style="font-family: 'Times New Roman','serif'">b</span><span style="font-family: 宋体">各有一个只有单个条件的判定结点。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="174" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b11.JPG" width="397" border="0" /><br />图</span> 10-4-8<span style="font-family: 宋体">　复合逻辑下的控制流图</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">2.</span><span style="font-family: 宋体">计算程序环路复杂性</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　进行程序的基本路径测试时，程序的环路复杂性给出了程序基本路径集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必需的测试用例数目的上界。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　所谓独立路径，是指包括一组以前没有处理的语句或条件的一条路径。如在图</span><span style="font-family: 'Times New Roman','serif'">10-4-9</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">b</span><span style="font-family: 宋体">）所示的控制流图中，一组独立的路径是</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">path1</span><span style="font-family: 宋体">：</span><span style="font-family: 'Times New Roman','serif'">1-11</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">path2</span><span style="font-family: 宋体">：</span><span style="font-family: 'Times New Roman','serif'">1-2-3-4-5-10-1-11</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">path3</span><span style="font-family: 宋体">：</span><span style="font-family: 'Times New Roman','serif'">1-2-3-6-8-9-10-1-11</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">path4</span><span style="font-family: 宋体">：</span><span style="font-family: 'Times New Roman','serif'">1-2-3-6-7-9-10-1-11</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　路径</span><span style="font-family: 'Times New Roman','serif'">path1</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">path2</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">path3</span><span style="font-family: 宋体">，</span><span style="font-family: 'Times New Roman','serif'">path4</span><span style="font-family: 宋体">组成了图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-9</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">b</span><span style="font-family: 宋体">）所示控制流图的一个基本路径集。只要设计出的测试用例能够确保这些基本路径的执行，就可以使得程序中的每个可执行语句至少执行一次，每个条件的取真和取假分支也能得到测试。基本路径集不是唯一的，对于给定的控制流图，可以得到不同的基本路径集。</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="238" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b12.JPG" width="223" border="0" /><br />（</span>a<span style="font-family: 宋体">）程序流程图</span></p>
<p style="layout-grid-mode: char; line-height: 16.75pt" align="center"></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体"><img height="268" alt="" src="https://images.cnblogs.com/cnblogs_com/jackc/b13.JPG" width="301" border="0" /><br />（</span>b<span style="font-family: 宋体">）控制流图</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char; line-height: 16.75pt" align="center"><span style="font-family: 宋体">图</span> 10-4-9<span style="font-family: 宋体">　程序流程图与对应的控制流图</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　通常环路复杂性可用以下</span><span style="font-family: 'Times New Roman','serif'">3</span><span style="font-family: 宋体">种方法求得。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">将环路复杂性定义为控制流图中的区域数。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">2</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">设</span><span style="font-family: 'Times New Roman','serif'">E</span><span style="font-family: 宋体">为控制流图的边数，</span><span style="font-family: 'Times New Roman','serif'">N</span><span style="font-family: 宋体">为图的结点数，则定义环路复杂性为</span><span style="font-family: 'Times New Roman','serif'">V</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">G</span><span style="font-family: 宋体">）＝</span><span style="font-family: 'Times New Roman','serif'">E</span><span style="font-family: 宋体">－</span><span style="font-family: 'Times New Roman','serif'">N</span><span style="font-family: 宋体">＋</span><span style="font-family: 'Times New Roman','serif'">2</span><span style="font-family: 宋体">。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　（</span><span style="font-family: 'Times New Roman','serif'">3</span><span style="font-family: 宋体">）</span> <span style="font-family: 宋体">若设</span><span style="font-family: 'Times New Roman','serif'">P</span><span style="font-family: 宋体">为控制流图中的判定结点数，则有</span><span style="font-family: 'Times New Roman','serif'">V</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">G</span><span style="font-family: 宋体">）＝</span><span style="font-family: 'Times New Roman','serif'">P</span><span style="font-family: 宋体">＋</span><span style="font-family: 'Times New Roman','serif'">1</span><span style="font-family: 宋体">。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　因为图</span><span style="font-family: 'Times New Roman','serif'"> 10-4-9</span><span style="font-family: 宋体">（</span><span style="font-family: 'Times New Roman','serif'">b</span><span style="font-family: 宋体">）所示控制流图有</span><span style="font-family: 'Times New Roman','serif'">4</span><span style="font-family: 宋体">个区域。其环路复杂性为</span><span style="font-family: 'Times New Roman','serif'">4</span><span style="font-family: 宋体">。它是构成基本路径集的独立路径数的上界。可以据此得到应该设计的测试用例的数目。</span></p>
<p style="margin: auto 0cm; layout-grid-mode: char"><span style="font-family: 宋体">　　</span><span style="font-family: 'Times New Roman','serif'">3.</span><span style="font-family: 宋体">导出测试用例</span></p><span style="font-size: 11pt; line-height: 115%; font-family: 宋体">　　利用逻辑覆盖方法生成测试用例，确保基本路径集中每条路径的执行。<br /><br /><span style="font-family: 宋体">Word版本下载地址<a href="http://files.cnblogs.com/Jackc/白盒测试用例设计方法.doc">/Files/Jackc/白盒测试用例设计方法.doc</a></span></span> </div><div id="MySignature"></div>


	        <div data-note-content class="show-content">
          <blockquote>
<p>白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。<strong>白盒测试是一种测试用例设计方法</strong>，盒子指的是被测试的软件，白盒指的是盒子是可视的，你清楚盒子内部的东西以及里面是如何运作的。"白盒"法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。"白盒"法是穷举路径测试。白盒测试并不是简单的按照代码设计用例，而是需要根据不同的测试需求，结合不同的测试对象，使用适合的方法进行测试。</p>
</blockquote>
<p>白盒测试用例设计的一个很重要的评估标准就是对代码的<strong>覆盖度</strong>。<strong>白盒测试中常见的覆盖方法有六种：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、组合覆盖和路径覆盖。下面我们就分别看看这几种不同的覆盖吧</strong>。</p>
<h2>一、语句覆盖（Statement Coverage）</h2>
<ol>
<li>主要特点：语句覆盖是最起码的结构覆盖要求，语句覆盖需要选择足够的测试用例，使我们设计出来的测试用例要<strong>保证程序中的每一个语句至少被执行一次</strong>。</li>
<li>优点：可以很直观地从源代码得到测试用例，无须细分每条判定表达式。</li>
<li>缺点：由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但对于隐藏的条件和可能到达的隐 式逻辑分支，是无法测试的。</li>
<li>举例</li>
</ol>
<pre><code>public int foo(int a,int b)
{
      return a/b;
}
</code></pre>
<p>这是一个求两数之商的函数。如果我们设计如下的测试用例：<br>
<code>TestCase: a =2, b =1</code><br>
此时，该函数的代码覆盖率达到了100%，并且设计的case可以顺利通过测试。但是显然该函数有一个很明显的bug：当 <code>b=0</code> 时，会抛出异常。</p>
<h2>二、判定覆盖（Decision Coverage）</h2>
<ol>
<li>主要特点：判定覆盖又称为分支覆盖，它要求<strong>选择足够的测试用例，使得运行这些测试用例时，每个判定的所有可能结果至少出现一次</strong>。</li>
<li>优点：判定覆盖比语句覆盖要多几乎一倍的测试路径，当然也就具有比语句覆盖更强的测试能力。同样判定覆盖也具有和语句覆盖一样的简单性，无须细分每个判定就可以得到测试用例。</li>
<li>缺点：往往大部分的判定语句是由多个逻辑条件组合而成（如，判定语句中包含AND、OR、CASE），若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。</li>
<li>
<p>举例</p>
<br>
<div class="image-package">
<div class="image-container" style="max-width: 392px; max-height: 255px;">
<div class="image-container-fill" style="padding-bottom: 65.05%;"></div>
<div class="image-view" data-width="392" data-height="255"><img data-original-src="//upload-images.jianshu.io/upload_images/2298827-34f2268901fe3fb7.png" data-original-width="392" data-original-height="255" data-original-format="image/png" data-original-filesize="34659"></div>
</div>
<div class="image-caption"></div>
</div>
</li>
</ol>
<pre><code>X    Y   路径
90  90  OAE
50  50  OBDE
90  70  OBCE
</code></pre>
<h2>三、条件覆盖（Condition Coverage）</h2>
<ol>
<li>主要特点：<strong>要求所设计的测试用例能使每个判定中的每一个条件都获得可能的取值，即每个条件至少有一次真值、有一次假值。</strong>
</li>
<li>优点：显然条件覆盖比判定覆盖，增加了对符合判定情况的测试，增加了测试路径。条件覆盖使得判定中的每一个条件都取到了不同的结果，这一点判定覆盖则无法保证。</li>
<li>缺点：要达到条件覆盖，需要足够多的测试用例，但条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果。</li>
<li>举例</li>
</ol>
<pre><code>X    Y   路径
90  70  OBC
40        OBD
</code></pre>
	<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp;&nbsp;<span style="line-height:24px; text-indent:28px">白盒测试</span><span style="line-height:24px; text-indent:28px">又称结构测试、透明盒测试、逻辑驱动测试或基于代码</span><span style="line-height:24px; text-indent:28px">的测试。白盒测试是一种测试用例设计方法</span><span style="line-height:24px; text-indent:28px">方法，盒子指的是被测试的软件</span><span style="line-height:24px; text-indent:28px">，白盒指的是盒子是可视的，你清楚盒子内部的东西以及里面是如何运作的。&quot;白盒&quot;法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。&quot;白盒&quot;法是穷举路径测试。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong><span style="line-height:24px; text-indent:2em">&nbsp; 白盒测试法的覆盖标准有逻辑覆盖</span><span style="line-height:24px; text-indent:2em">、循环覆盖和基本路径测试。今天我们主要研究逻辑覆盖，逻辑覆盖包括语句覆盖</span><span style="line-height:24px; text-indent:2em">、判定覆盖</span><span style="line-height:24px; text-indent:2em">、条件覆盖</span><span style="line-height:24px; text-indent:2em">、判定/条件覆盖、条件组合覆盖</span><span style="line-height:24px; text-indent:2em">和路径覆盖</span><span style="line-height:24px; text-indent:2em">。</span></strong></span></p>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 下图是一个普通的程序流程图，其中有两个判定语句和两个复制语句，以及四条路径L1：ace，L2：abd，L3：abe，L4：acd。</strong></span></span></p>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp;&nbsp;<img src="http://img.blog.csdn.net/20150505153708972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDkyNjk2NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></strong></span></span></p>
<h2><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="color:#666666">&nbsp;</span>1.语句覆盖每条语句至少执行一次。</strong></span></span></h2>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 我们可以创建一个测试用例（2，0，4）使得覆盖图中所有的语句（包括判定语句和赋&#20540;语句），也就是走L1路径，它并没有覆盖所有的路径，因此语句覆盖的覆盖程度最低。</strong></span></span></p>
<h2><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="color:#666666">&nbsp;</span>2.判定覆盖又称分支覆盖，它不仅每个语句执行一次，而且每个判定的每种可能都执行一次。</strong></span></span></h2>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 为了达到上图的判定覆盖，我们可以创建（2，0，4）（1，1，1）两个测试用例，使得图中两个判定中每个判定的真假情况都执行一遍。这两个测试用例也只能覆盖L1，L2两条路径，因此判定覆盖覆盖强度高于语句覆盖，但对逻辑覆盖的轻度仍然不是很高。</strong></span></span></p>
<h2><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="color:#666666">&nbsp;</span>3.条件覆盖每个判定的每个条件应取到各种可能的&#20540;。</strong></span></span></h2>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 这里就要说明条件跟判定的区别，上图中共有两个判定，每个判定中又都有两个条件即A&gt;1、B=0分别是一个条件，两个条件组合成了一个判定。条件判定覆盖既要将每个判定中的每个条件的每一种可能情况都覆盖一遍。同样测试用例（2，0，4）（1，1，1）可以满足条件覆盖，大家可能看到了这两个测试用例满足于判定覆盖，又满足了条件覆盖，那么这两中覆盖之间是什么关系呢？可以说他们两个之间没有确切的关系，也并不是说满足条件覆盖的就一定满足判定覆盖，或者满足判定覆盖的就一次能够满足条件覆盖。只是条件覆盖的情况更复杂一些，而测试用例只需要覆盖所有的条件即可，本实例中只是恰好这两个测试用例同时满足了判定覆盖和条件覆盖，希望大家不要被误导。</strong></span></span></p>
<h2><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong>&nbsp; 4.判定/条件覆盖同时满足判定覆盖条件覆盖。</strong></span></span></h2>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 从这一种逻辑覆盖中就可以看出条件覆盖和判定覆盖之间并没有包含关系，因为如果他们其中之一包含了另一个的话就不用同时满足两个覆盖才称之为<span style="line-height:24px; text-indent:28px">判定/条件覆盖</span>。因为测试用例（2，0，4）（1，1，1）同时满足条件覆盖和判定覆盖，所以这两个测试用例肯定满足<span style="line-height:24px; text-indent:28px">判定/条件覆盖，但是<span style="line-height:24px; text-indent:28px">判定/条件覆盖也能覆盖所有的路径。</span></span></strong></span></span></p>
<h2><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="color:#666666">&nbsp;</span> 5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。</strong></span></span></h2>
<p><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 上图中的条件取&#20540;组合以及测试用例如下：</strong></span></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong><span style="line-height:24px; text-indent:2em">&nbsp;&nbsp;</span><img src="http://img.blog.csdn.net/20150505161401414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDkyNjk2NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="line-height:24px; text-indent:2em">&nbsp;
 &nbsp; &nbsp;&nbsp;<img src="http://img.blog.csdn.net/20150505161739924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDkyNjk2NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" width="600" height="300" alt=""></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 可以看出来即使条件组合覆盖比较复杂，但是还没有覆盖所有的路径，因此我们需要覆盖强度更高的逻辑覆盖。</strong></span></p>
<h2><span style="line-height:24px; text-indent:2em"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="color:#666666">&nbsp;</span> 6.路径覆盖使程序中每一条可能的路径至少执行一次。</strong></span></span></h2>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp;&nbsp;<img src="http://img.blog.csdn.net/20150505162314730?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDkyNjk2NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#666666"><strong>&nbsp; 六种覆盖中只有路径覆盖将所有的路径都执行一遍，但是无论哪种覆盖，都不能保证程序的正确性，测试的目的就是发现程序存在的问题，而不是证明程序没有问题，以上几种逻辑覆盖只是自己学习的一些整理，有不足之处希望大家批评指正。</strong></span></p>

	
</p><p>
④【警戒线】这词虽然有许多种用法，但在本作中是指迎击线或巡逻线。尽管遭到突破的后果会很严重，却意外容易遭到突破。</p><p>
</p><p>
⑤【ROE】这边是指交战规则，跟股东报酬率无关。根据足立纯夫教授的定义，是基于「在事前对战术行动可能引发的意外事态进行谨慎评估，让该事态的法学论述能适用于具体问题，并特别针对需行使战斗的事态以及其方式进行详细规范」所制定的规则。若要说得简单点，就是干架的规矩。</p>
			</div>
			<div class="t" id="chapter_contents" style="display:none;">
			</div>
		</div>
		<div class="section4" id="control_block">
			<p class="zlist" style="text-align:center;padding-top:20px;">
				<a href="javascript:;" onclick="changeChapter(&#39;prev&#39;)" class="list_href prevcolor" id="prevChapter" title="上一章">上一章</a>

				<a href="javascript:;" onclick="loadPage(&#39;prev&#39;)" class="list_href prevcolor" id="prevPage" title="上一页" style="display:none;">上一页</a>
				&nbsp;&nbsp;<span id="page_num_span" style="color:#999">1/26</span>&nbsp;&nbsp;
				<a href="javascript:;" onclick="loadPage(&#39;next&#39;)" class="list_href nextcolor" id="nextPage" title="下一页">下一页</a>

				<a href="javascript:;" onclick="changeChapter(&#39;next&#39;)" class="list_href nextcolor" id="nextChapter" title="下一章" style="display:none;">下一章</a>
			</p>
		</div>
		<div style="display:none;">
			<script>var g_pre_page=2;</script><a href="http://q.dmzj.com/1804/6605/47364.shtml" id="pre_chapter">上一话</a><a href="http://q.dmzj.com/1804/6605/47366.shtml" id="next_chapter">下一话</a><script>var g_next_page=2 ;</script>
		</div>
		<div id="toolbar_bottom" class="bottom" style="">
			<a href="javascript:;" onclick="fontSize(this)" id="font_size_a" class="cn5"></a><span id="font_size_span" class="cn5" style="display:none;"><a href="javascript:;" class="add" onclick="changeFontSize(&#39;big&#39;)"></a><a href="javascript:;" class="acc" onclick="changeFontSize(&#39;small&#39;)"></a></span>
			<a href="javascript:;" class="cn7 on" onclick="changeLight(this)" id="light_a" type="on"></a>
			<span class="pag"><select id="jump_select"><option value="">跳转到</option><option value="1">第1页</option><option value="2">第2页</option><option value="3">第3页</option><option value="4">第4页</option><option value="5">第5页</option><option value="6">第6页</option><option value="7">第7页</option><option value="8">第8页</option><option value="9">第9页</option><option value="10">第10页</option><option value="11">第11页</option><option value="12">第12页</option><option value="13">第13页</option><option value="14">第14页</option><option value="15">第15页</option><option value="16">第16页</option><option value="17">第17页</option><option value="18">第18页</option><option value="19">第19页</option><option value="20">第20页</option><option value="21">第21页</option><option value="22">第22页</option><option value="23">第23页</option><option value="24">第24页</option><option value="25">第25页</option><option value="26">第26页</option></select></span>
		</div>

		<div id="cite_vote" style="background-color:#fafafa;display:none;">
			<div class="toolbar" style="display:block;">
				<a href="javascript:;" onclick="citeShow(0);" class="back"></a>
				<div class="title">吐 槽</div>
			</div>
			<div id="sns_cite_vote_list" style="margin-top:40px;"></div>
		</div>
		<div class="mask_panel" id="mask_panel" style="position:fixed;">
		</div>
		<div class="pop_grade toolbar_b" id="pop_grade" style="position:fixed;width:100%;z-index:10000;">
			<div class="shareBox" id="shareBox">
				<strong>分享到</strong>
					<a class="w1" href="http://v.t.sina.com.cn/share/share.php?appkey=3938048249&amp;url=http%3A%2F%2Fq.dmzj.com%2F1804%2F6605%2F47365.shtml" title="新浪微博"><i></i></a>
					<a class="w2" href="http://v.t.qq.com/share/share.php?title=%E7%AC%AC%E4%B8%80%E5%8D%B7%20Deus%20lo%20vult_%E7%AC%AC%E5%8F%82%E7%AB%A0%20%E5%AE%88%E6%9C%9B%E8%8E%B1%E8%8C%B5_%E5%B9%BC%E5%A5%B3%E6%88%98%E8%AE%B0%E5%9C%A8%E7%BA%BF%E8%BD%BB%E5%B0%8F%E8%AF%B4_%E5%B9%BC%E5%A5%B3%E6%88%98%E8%AE%B0%E6%89%8B%E6%9C%BA%E5%B0%8F%E8%AF%B4&amp;url=http%3A%2F%2Fq.dmzj.com%2F1804%2F6605%2F47365.shtml&amp;appkey=8b5c8745ea364613adfda05c616d9abe" title="腾讯微博"><i></i></a>
			</div>
		</div>

	</div>
	<div style="display:none;">
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000465408'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "w.cnzz.com/q_stat.php%3Fid%3D1000465408' type='text/javascript'%3E%3C/script%3E"));</script><span id="cnzz_stat_icon_1000465408"></span><script src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/q_stat.php" type="text/javascript"></script>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F645dcc265dc58142b6dbfea748247f02' type='text/javascript'%3E%3C/script%3E"));
</script><script src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/h.js.download" type="text/javascript"></script><a href="http://tongji.baidu.com/hm-web/welcome/ico?s=645dcc265dc58142b6dbfea748247f02" target="_blank"><img border="0" src="./第一卷 Deus lo vult_第参章 守望莱茵_幼女战记在线轻小说_幼女战记手机小说_files/21.gif" width="20" height="20"></a>
</div>


</body></html>
